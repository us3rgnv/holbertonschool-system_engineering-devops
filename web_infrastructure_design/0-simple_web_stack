## Start: a user wants to access the website

1. A user opens a browser and types **[www.foobar.com](http://www.foobar.com)** or clicks a link to **[https://www.foobar.com](https://www.foobar.com)**.
2. The browser performs a DNS lookup for `www.foobar.com` and receives the IP address `8.8.8.8`.
3. The browser connects to the single server at `8.8.8.8` and requests the web page (HTTP/HTTPS).

---

## Top-level diagram (whiteboard view)

```
+---------------------------+
| Internet / User Browser   |
+-----------+---------------+
            |
            | DNS: www.foobar.com -> A 8.8.8.8
            |
+-----------v-------------------------------+
| Single Server (IP 8.8.8.8)                 |
|  - OS (Linux)                              |
|  - Nginx (web server, listens on 80/443)  |
|  - App server (e.g. uWSGI, Gunicorn, Node) |
|  - App files (codebase under /var/www)     |
|  - MySQL database (local, port 3306)       |
+--------------------------------------------+
            |
            +--> Data persisted in MySQL (database files)
```

---

## DNS configuration (required by the task)

* Domain: `foobar.com`
* `www` record: **A** record pointing to `8.8.8.8` (example DNS zone line):

```
www IN A 8.8.8.8
```

> Note: `www` could also be a CNAME to `foobar.com`, but because the task explicitly gives an IP (`8.8.8.8`) we use an **A** record.

---

## Components (what's on the single server)

* **Server** — the physical or virtual machine (VM) providing CPU, memory, disk, and network. It runs the OS and all server-side software.

* **Web server (Nginx)** — receives incoming HTTP(S) requests on port 80/443, handles TLS termination (if used), serves static files, and reverse-proxies dynamic requests to the application server.

  Example minimal `server` block (nginx):

  ```nginx
  server {
    listen 80;
    server_name www.foobar.com foobar.com;

    root /var/www/foobar/current/public;

    location / {
      proxy_pass http://127.0.0.1:8000; # app server upstream
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
    }
  }
  ```

* **Application server** — the process that runs your application code (examples: Gunicorn for Python, uWSGI, Passenger, a Node.js process). It accepts proxied requests from the web server, runs business logic, talks to the database, and returns dynamic HTML/JSON.

* **Application files** — your codebase and static assets (e.g., placed in `/var/www/foobar`), managed with Git (the repo provided: `holbertonschool-system_engineering-devops/web_infrastructure_design/0-simple_web_stack`).

* **Database (MySQL)** — stores persistent data (users, posts, etc.). In this design MySQL runs on the same machine and listens on `localhost:3306` (or on all interfaces if explicitly configured).

---

## Network / Protocol details (how the server communicates with the user)

* The client's browser and the server communicate over the **Internet** using the **TCP/IP** stack.
* The application-level protocol is **HTTP** or **HTTPS** (TLS over TCP). Typical ports: **80** (HTTP) and **443** (HTTPS).
* Flow: Browser -> DNS -> TCP connection to 8.8.8.8:80/443 -> Nginx -> reverse proxy to local app server (e.g., 127.0.0.1:8000) -> app -> DB (localhost:3306) -> response back to client.

---

## Definitions / Roles 

* **What is a server?**
  A server is a machine (physical or virtual) that provides compute, storage, and networking to run software which serves data or functionality to clients.

* **What is the role of the domain name?**
  The domain (foobar.com) provides a human-friendly name. DNS resolves that name (e.g. `www.foobar.com`) to an IP address (8.8.8.8) so clients can contact the server.

* **What type of DNS record is `www` in `www.foobar.com`?**
  In this task, `www` is an **A** record that points directly to the IP address `8.8.8.8`.

* **What is the role of the web server?**
  Nginx handles incoming HTTP(S) requests, serves static files, terminates TLS, and proxies dynamic requests to the application server.

* **What is the role of the application server?**
  The application server runs your application code (framework), executes business logic, accesses the database, and produces dynamic responses.

* **What is the role of the database?**
  MySQL stores and retrieves persistent structured data required by the application (users, sessions, content, etc.).

* **What is the server using to communicate with the user's computer?**
  It uses the Internet TCP/IP protocol stack and the HTTP/HTTPS application protocol over TCP (usually ports 80 and 443). DNS (UDP/TCP) is used to first resolve the domain to the IP.

---

## Problems / Limitations of this single-server design

1. **Single point of failure (SPOF)**

   * If the server fails (hardware, OS crash, kernel panic), the entire website becomes unavailable.

2. **Downtime during maintenance / deploys**

   * Restarting Nginx or the application server for configuration changes or deploys can cause user-visible downtime unless you use careful strategies (zero-downtime deployment, socket handoff, etc.).

3. **Cannot scale with high traffic**

   * One server limits CPU, RAM, network bandwidth, and I/O; heavy traffic will exhaust resources and degrade performance.

4. **Resource contention**

   * Web server, app server, and database share the same resources; a spike in DB usage can slow down the app and web serving.

5. **Security blast radius**

   * If an attacker compromises the server, they gain access to application code and production database.

---

